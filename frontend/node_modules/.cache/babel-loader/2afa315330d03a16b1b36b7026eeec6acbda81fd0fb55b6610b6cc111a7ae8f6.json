{"ast":null,"code":"'use strict';\n\nconst util = require('util');\nconst pMap = require('p-map');\nconst contentPath = require('./content/path');\nconst fixOwner = require('./util/fix-owner');\nconst fs = require('@npmcli/fs');\nconst fsm = require('fs-minipass');\nconst glob = util.promisify(require('glob'));\nconst index = require('./entry-index');\nconst path = require('path');\nconst rimraf = util.promisify(require('rimraf'));\nconst ssri = require('ssri');\nconst globify = pattern => pattern.split('\\\\').join('/');\nconst hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\nconst verifyOpts = opts => ({\n  concurrency: 20,\n  log: {\n    silly() {}\n  },\n  ...opts\n});\nmodule.exports = verify;\nasync function verify(cache, opts) {\n  opts = verifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  const steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n  const stats = {};\n  for (const step of steps) {\n    const label = step.name;\n    const start = new Date();\n    const s = await step(cache, opts);\n    if (s) {\n      Object.keys(s).forEach(k => {\n        stats[k] = s[k];\n      });\n    }\n    const end = new Date();\n    if (!stats.runTime) {\n      stats.runTime = {};\n    }\n    stats.runTime[label] = end - start;\n  }\n  stats.runTime.total = stats.endTime - stats.startTime;\n  opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n  return stats;\n}\nasync function markStartTime(cache, opts) {\n  return {\n    startTime: new Date()\n  };\n}\nasync function markEndTime(cache, opts) {\n  return {\n    endTime: new Date()\n  };\n}\nasync function fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  await fixOwner.mkdirfix(cache, cache);\n  // TODO - fix file permissions too\n  await fixOwner.chownr(cache, cache);\n  return null;\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nasync function garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  const indexStream = index.lsStream(cache);\n  const liveContent = new Set();\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) {\n      return;\n    }\n    liveContent.add(entry.integrity.toString());\n  });\n  await new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject);\n  });\n  const contentDir = contentPath.contentDir(cache);\n  const files = await glob(globify(path.join(contentDir, '**')), {\n    follow: false,\n    nodir: true,\n    nosort: true\n  });\n  const stats = {\n    verifiedContent: 0,\n    reclaimedCount: 0,\n    reclaimedSize: 0,\n    badContentCount: 0,\n    keptSize: 0\n  };\n  await pMap(files, async f => {\n    const split = f.split(/[/\\\\]/);\n    const digest = split.slice(split.length - 3).join('');\n    const algo = split[split.length - 4];\n    const integrity = ssri.fromHex(digest, algo);\n    if (liveContent.has(integrity.toString())) {\n      const info = await verifyContent(f, integrity);\n      if (!info.valid) {\n        stats.reclaimedCount++;\n        stats.badContentCount++;\n        stats.reclaimedSize += info.size;\n      } else {\n        stats.verifiedContent++;\n        stats.keptSize += info.size;\n      }\n    } else {\n      // No entries refer to this content. We can delete.\n      stats.reclaimedCount++;\n      const s = await fs.stat(f);\n      await rimraf(f);\n      stats.reclaimedSize += s.size;\n    }\n    return stats;\n  }, {\n    concurrency: opts.concurrency\n  });\n  return stats;\n}\nasync function verifyContent(filepath, sri) {\n  const contentInfo = {};\n  try {\n    const {\n      size\n    } = await fs.stat(filepath);\n    contentInfo.size = size;\n    contentInfo.valid = true;\n    await ssri.checkStream(new fsm.ReadStream(filepath), sri);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return {\n        size: 0,\n        valid: false\n      };\n    }\n    if (err.code !== 'EINTEGRITY') {\n      throw err;\n    }\n    await rimraf(filepath);\n    contentInfo.valid = false;\n  }\n  return contentInfo;\n}\nasync function rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  const entries = await index.ls(cache);\n  const stats = {\n    missingContent: 0,\n    rejectedEntries: 0,\n    totalEntries: 0\n  };\n  const buckets = {};\n  for (const k in entries) {\n    /* istanbul ignore else */\n    if (hasOwnProperty(entries, k)) {\n      const hashed = index.hashKey(k);\n      const entry = entries[k];\n      const excluded = opts.filter && !opts.filter(entry);\n      excluded && stats.rejectedEntries++;\n      if (buckets[hashed] && !excluded) {\n        buckets[hashed].push(entry);\n      } else if (buckets[hashed] && excluded) {\n        // skip\n      } else if (excluded) {\n        buckets[hashed] = [];\n        buckets[hashed]._path = index.bucketPath(cache, k);\n      } else {\n        buckets[hashed] = [entry];\n        buckets[hashed]._path = index.bucketPath(cache, k);\n      }\n    }\n  }\n  await pMap(Object.keys(buckets), key => {\n    return rebuildBucket(cache, buckets[key], stats, opts);\n  }, {\n    concurrency: opts.concurrency\n  });\n  return stats;\n}\nasync function rebuildBucket(cache, bucket, stats, opts) {\n  await fs.truncate(bucket._path);\n  // This needs to be serialized because cacache explicitly\n  // lets very racy bucket conflicts clobber each other.\n  for (const entry of bucket) {\n    const content = contentPath(cache, entry.integrity);\n    try {\n      await fs.stat(content);\n      await index.insert(cache, entry.key, entry.integrity, {\n        metadata: entry.metadata,\n        size: entry.size\n      });\n      stats.totalEntries++;\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        stats.rejectedEntries++;\n        stats.missingContent++;\n      } else {\n        throw err;\n      }\n    }\n  }\n}\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\nfunction writeVerifile(cache, opts) {\n  const verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n  try {\n    return fs.writeFile(verifile, `${Date.now()}`);\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\nmodule.exports.lastRun = lastRun;\nasync function lastRun(cache) {\n  const data = await fs.readFile(path.join(cache, '_lastverified'), {\n    encoding: 'utf8'\n  });\n  return new Date(+data);\n}","map":{"version":3,"names":["util","require","pMap","contentPath","fixOwner","fs","fsm","glob","promisify","index","path","rimraf","ssri","globify","pattern","split","join","hasOwnProperty","obj","key","Object","prototype","call","verifyOpts","opts","concurrency","log","silly","module","exports","verify","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","stats","step","label","name","start","Date","s","keys","forEach","k","end","runTime","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","filter","add","integrity","toString","Promise","resolve","reject","contentDir","files","follow","nodir","nosort","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","f","digest","slice","length","algo","fromHex","has","info","verifyContent","valid","size","stat","filepath","sri","contentInfo","checkStream","ReadStream","err","code","entries","ls","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","bucket","truncate","content","insert","metadata","verifile","writeFile","now","sync","lastRun","data","readFile","encoding"],"sources":["/Users/altafziya/Desktop/new project/ak collection/frontend/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('@npmcli/fs')\nconst fsm = require('fs-minipass')\nconst glob = util.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nconst globify = pattern => pattern.split('\\\\').join('/')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts,\n})\n\nmodule.exports = verify\n\nasync function verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime,\n  ]\n\n  const stats = {}\n  for (const step of steps) {\n    const label = step.name\n    const start = new Date()\n    const s = await step(cache, opts)\n    if (s) {\n      Object.keys(s).forEach((k) => {\n        stats[k] = s[k]\n      })\n    }\n    const end = new Date()\n    if (!stats.runTime) {\n      stats.runTime = {}\n    }\n    stats.runTime[label] = end - start\n  }\n  stats.runTime.total = stats.endTime - stats.startTime\n  opts.log.silly(\n    'verify',\n    'verification finished for',\n    cache,\n    'in',\n    `${stats.runTime.total}ms`\n  )\n  return stats\n}\n\nasync function markStartTime (cache, opts) {\n  return { startTime: new Date() }\n}\n\nasync function markEndTime (cache, opts) {\n  return { endTime: new Date() }\n}\n\nasync function fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  await fixOwner.mkdirfix(cache, cache)\n  // TODO - fix file permissions too\n  await fixOwner.chownr(cache, cache)\n  return null\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nasync function garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry)) {\n      return\n    }\n\n    liveContent.add(entry.integrity.toString())\n  })\n  await new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  })\n  const contentDir = contentPath.contentDir(cache)\n  const files = await glob(globify(path.join(contentDir, '**')), {\n    follow: false,\n    nodir: true,\n    nosort: true,\n  })\n  const stats = {\n    verifiedContent: 0,\n    reclaimedCount: 0,\n    reclaimedSize: 0,\n    badContentCount: 0,\n    keptSize: 0,\n  }\n  await pMap(\n    files,\n    async (f) => {\n      const split = f.split(/[/\\\\]/)\n      const digest = split.slice(split.length - 3).join('')\n      const algo = split[split.length - 4]\n      const integrity = ssri.fromHex(digest, algo)\n      if (liveContent.has(integrity.toString())) {\n        const info = await verifyContent(f, integrity)\n        if (!info.valid) {\n          stats.reclaimedCount++\n          stats.badContentCount++\n          stats.reclaimedSize += info.size\n        } else {\n          stats.verifiedContent++\n          stats.keptSize += info.size\n        }\n      } else {\n        // No entries refer to this content. We can delete.\n        stats.reclaimedCount++\n        const s = await fs.stat(f)\n        await rimraf(f)\n        stats.reclaimedSize += s.size\n      }\n      return stats\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function verifyContent (filepath, sri) {\n  const contentInfo = {}\n  try {\n    const { size } = await fs.stat(filepath)\n    contentInfo.size = size\n    contentInfo.valid = true\n    await ssri.checkStream(new fsm.ReadStream(filepath), sri)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return { size: 0, valid: false }\n    }\n    if (err.code !== 'EINTEGRITY') {\n      throw err\n    }\n\n    await rimraf(filepath)\n    contentInfo.valid = false\n  }\n  return contentInfo\n}\n\nasync function rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  const entries = await index.ls(cache)\n  const stats = {\n    missingContent: 0,\n    rejectedEntries: 0,\n    totalEntries: 0,\n  }\n  const buckets = {}\n  for (const k in entries) {\n    /* istanbul ignore else */\n    if (hasOwnProperty(entries, k)) {\n      const hashed = index.hashKey(k)\n      const entry = entries[k]\n      const excluded = opts.filter && !opts.filter(entry)\n      excluded && stats.rejectedEntries++\n      if (buckets[hashed] && !excluded) {\n        buckets[hashed].push(entry)\n      } else if (buckets[hashed] && excluded) {\n        // skip\n      } else if (excluded) {\n        buckets[hashed] = []\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      } else {\n        buckets[hashed] = [entry]\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      }\n    }\n  }\n  await pMap(\n    Object.keys(buckets),\n    (key) => {\n      return rebuildBucket(cache, buckets[key], stats, opts)\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function rebuildBucket (cache, bucket, stats, opts) {\n  await fs.truncate(bucket._path)\n  // This needs to be serialized because cacache explicitly\n  // lets very racy bucket conflicts clobber each other.\n  for (const entry of bucket) {\n    const content = contentPath(cache, entry.integrity)\n    try {\n      await fs.stat(content)\n      await index.insert(cache, entry.key, entry.integrity, {\n        metadata: entry.metadata,\n        size: entry.size,\n      })\n      stats.totalEntries++\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        stats.rejectedEntries++\n        stats.missingContent++\n      } else {\n        throw err\n      }\n    }\n  }\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return fs.writeFile(verifile, `${Date.now()}`)\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\n\nasync function lastRun (cache) {\n  const data = await fs.readFile(path.join(cache, '_lastverified'), { encoding: 'utf8' })\n  return new Date(+data)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nconst fs = require('@npmcli/fs');\nconst move = require('@npmcli/move-file');\nconst pinflight = require('promise-inflight');\nmodule.exports = moveFile;\nasync function moveFile(src, dest) {\n  const isWindows = process.platform === 'win32';\n\n  // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n  try {\n    await fs.link(src, dest);\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {\n      // XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n      // file already exists, so whatever\n    } else {\n      throw err;\n    }\n  }\n  try {\n    await Promise.all([fs.unlink(src), !isWindows && fs.chmod(dest, '0444')]);\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch(err => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err;\n        }\n      });\n      // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n      return move(src, dest);\n    });\n  }\n}","map":{"version":3,"names":["fs","require","move","pinflight","module","exports","moveFile","src","dest","isWindows","process","platform","link","err","code","Promise","all","unlink","chmod","e","stat","catch"],"sources":["/Users/altafziya/Desktop/new project/ak collection/frontend/node_modules/cacache/lib/util/move-file.js"],"sourcesContent":["'use strict'\n\nconst fs = require('@npmcli/fs')\nconst move = require('@npmcli/move-file')\nconst pinflight = require('promise-inflight')\n\nmodule.exports = moveFile\n\nasync function moveFile (src, dest) {\n  const isWindows = process.platform === 'win32'\n\n  // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n  try {\n    await fs.link(src, dest)\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {\n      // XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n      // file already exists, so whatever\n    } else {\n      throw err\n    }\n  }\n  try {\n    await Promise.all([\n      fs.unlink(src),\n      !isWindows && fs.chmod(dest, '0444'),\n    ])\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch((err) => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err\n        }\n      })\n      // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n      return move(src, dest)\n    })\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,YAAY,CAAC;AAChC,MAAMC,IAAI,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACzC,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAE7CG,MAAM,CAACC,OAAO,GAAGC,QAAQ;AAEzB,eAAeA,QAAQ,CAAEC,GAAG,EAAEC,IAAI,EAAE;EAClC,MAAMC,SAAS,GAAGC,OAAO,CAACC,QAAQ,KAAK,OAAO;;EAE9C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI;IACF,MAAMX,EAAE,CAACY,IAAI,CAACL,GAAG,EAAEC,IAAI,CAAC;EAC1B,CAAC,CAAC,OAAOK,GAAG,EAAE;IACZ,IAAIJ,SAAS,IAAII,GAAG,CAACC,IAAI,KAAK,OAAO,EAAE;MACrC;MACA;MACA;MACA;MACA;MACA;MACA;IAAA,CACD,MAAM,IAAID,GAAG,CAACC,IAAI,KAAK,QAAQ,IAAID,GAAG,CAACC,IAAI,KAAK,OAAO,EAAE;MACxD;IAAA,CACD,MAAM;MACL,MAAMD,GAAG;IACX;EACF;EACA,IAAI;IACF,MAAME,OAAO,CAACC,GAAG,CAAC,CAChBhB,EAAE,CAACiB,MAAM,CAACV,GAAG,CAAC,EACd,CAACE,SAAS,IAAIT,EAAE,CAACkB,KAAK,CAACV,IAAI,EAAE,MAAM,CAAC,CACrC,CAAC;EACJ,CAAC,CAAC,OAAOW,CAAC,EAAE;IACV,OAAOhB,SAAS,CAAC,oBAAoB,GAAGK,IAAI,EAAE,YAAY;MACxD,MAAMR,EAAE,CAACoB,IAAI,CAACZ,IAAI,CAAC,CAACa,KAAK,CAAER,GAAG,IAAK;QACjC,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;UACzB;UACA,MAAMD,GAAG;QACX;MACF,CAAC,CAAC;MACF;MACA;MACA,OAAOX,IAAI,CAACK,GAAG,EAAEC,IAAI,CAAC;IACxB,CAAC,CAAC;EACJ;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}
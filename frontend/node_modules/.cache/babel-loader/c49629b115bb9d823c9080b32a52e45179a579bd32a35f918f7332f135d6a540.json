{"ast":null,"code":"const Minipass = require('minipass');\nconst fetch = require('minipass-fetch');\nconst promiseRetry = require('promise-retry');\nconst ssri = require('ssri');\nconst CachingMinipassPipeline = require('./pipeline.js');\nconst getAgent = require('./agent.js');\nconst pkg = require('../package.json');\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET',\n// remote socket closed on us\n'ECONNREFUSED',\n// remote host refused to open connection\n'EADDRINUSE',\n// failed to bind to a local port (proxy?)\n'ETIMEDOUT',\n// someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\n\nconst RETRY_TYPES = ['request-timeout'];\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  }\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT);\n  }\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts);\n    try {\n      let res = await fetch(req, _opts);\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          algorithms: _opts.algorithms,\n          integrity: _opts.integrity,\n          size: _opts.size\n        });\n        const pipeline = new CachingMinipassPipeline({\n          events: ['integrity', 'size']\n        }, res.body, integrityStream);\n        // we also propagate the integrity and size events out to the pipeline so we can use\n        // this new response body as an integrityEmitter for cacache\n        integrityStream.on('integrity', i => pipeline.emit('integrity', i));\n        integrityStream.on('size', s => pipeline.emit('size', s));\n        res = new fetch.Response(pipeline, res);\n        // set an explicit flag so we know if our response body will emit integrity and size\n        res.body.hasIntegrityEmitter = true;\n      }\n      res.headers.set('x-fetch-attempts', attemptNum);\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body);\n      const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(res);\n        }\n        return retryHandler(res);\n      }\n      return res;\n    } catch (err) {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n      if (req.method === 'POST' || isRetryError) {\n        throw err;\n      }\n      if (typeof options.onRetry === 'function') {\n        options.onRetry(err);\n      }\n      return retryHandler(err);\n    }\n  }, options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err;\n    }\n    throw err;\n  });\n};\nmodule.exports = remoteFetch;","map":{"version":3,"names":["Minipass","require","fetch","promiseRetry","ssri","CachingMinipassPipeline","getAgent","pkg","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","redirect","retryHandler","attemptNum","req","Request","res","integrity","status","integrityStream","algorithms","size","pipeline","events","body","on","i","emit","s","Response","hasIntegrityEmitter","isStream","isRetriable","method","includes","onRetry","err","code","retried","isRetryError","type","retry","catch","module","exports"],"sources":["/Users/altafziya/Desktop/new project/ak collection/frontend/node_modules/make-fetch-happen/lib/remote.js"],"sourcesContent":["const Minipass = require('minipass')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst CachingMinipassPipeline = require('./pipeline.js')\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n  }\n\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT)\n  }\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          algorithms: _opts.algorithms,\n          integrity: _opts.integrity,\n          size: _opts.size,\n        })\n        const pipeline = new CachingMinipassPipeline({\n          events: ['integrity', 'size'],\n        }, res.body, integrityStream)\n        // we also propagate the integrity and size events out to the pipeline so we can use\n        // this new response body as an integrityEmitter for cacache\n        integrityStream.on('integrity', i => pipeline.emit('integrity', i))\n        integrityStream.on('size', s => pipeline.emit('size', s))\n        res = new fetch.Response(pipeline, res)\n        // set an explicit flag so we know if our response body will emit integrity and size\n        res.body.hasIntegrityEmitter = true\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(res)\n        }\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err\n      }\n\n      if (typeof options.onRetry === 'function') {\n        options.onRetry(err)\n      }\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err\n    }\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}